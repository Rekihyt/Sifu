const std = @import("std");
const parser = @import("parser.zig");
const ast = @import("ast.zig");
const Node = ast.Node;
const errors = @import("error.zig");
const Allocator = std.mem.Allocator;
const testing = std.testing;
const Parser = parser.Parser;

/// Compiles the source code into sifu's bytecode
pub fn compile(
    allocator: Allocator,
    source: []const u8,
    _errors: errors.Errors,
) (Parser.Error || Compiler.Error)!void {
    const tree = try parser.parse(allocator, source, _errors);
    defer tree.deinit();
}

/// Returns true if the given `Node` can be forward declared
fn canBeForwardDeclared(node: Node) bool {
    return switch (node) {
        .int_lit,
        .string_lit,
        .func_lit,
        .data_structure,
        .nil,
        .slice,
        => true,
        else => false,
    };
}

/// Contains the memory and generated instructions
/// after calling Compile()
pub const Compiler = struct {
    /// Allocator used to allocate to the heap, call deinit() on compiler to free all memory
    allocator: *Allocator,
    /// Any errors generated by the compiler will be appended to `errors`
    errors: *errors.Errors,
    /// Imported modules and their global symboltable
    modules: std.StringHashMapUnmanaged(*Module),
    /// Arena states which will be freed once we finished compilation
    /// This ensures all Nodes that are imported from other files have a long enough
    /// lifetime to be used for typechecking imported functions/variables
    module_states: std.ArrayListUnmanaged(std.heap.ArenaAllocator.State),

    /// Compiler errorset
    pub const Error = error{ CompilerError, OutOfMemory };

    /// Hashmap of `Symbol` where the key is the Symbol's name
    const SymbolTable = std.StringArrayHashMapUnmanaged(*Symbol);

    /// Symbols known by the compiler
    const Symbol = struct {
        name: []const u8,
        /// The `Node` that declared the symbol, used to retrieve the symbol's type
        node: Node,
    };

    /// Module with its global symbols
    const Module = struct {
        /// symbols existing inside the module
        symbols: SymbolTable,
        /// used to determine if module still requires codegen
        compiled: bool,
    };

    /// Scope of the current state (function, global, etc)
    const Scope = struct {
        /// Symbols that exist within the current scope
        symbols: SymbolTable,
        /// Type of the Scope. i.e. Root, function, etc
        id: Tag,
        /// If not a global scope, the scope will own a parent
        parent: ?*Scope = null,
        /// used to create child scopes
        allocator: *Allocator,
        /// The offset used to calculate symbol indices
        offset: u16 = 0,

        /// The type of the scope
        const Id = enum {
            global,
            function,
            loop,
            module,
        };

        const Tag = union(Id) {
            global,
            loop,
            module: void,
            function: *Node.FunctionLiteral,
        };

        /// Creates a new `Scope` from the current Scope.
        /// The new Scope will have its parent set to the current Scope
        fn fork(self: *Scope, id: Scope.Id) !*Scope {
            const new_scope = try self.allocator.create(Scope);
            new_scope.* = .{
                .symbols = SymbolTable{},
                .id = switch (id) {
                    .global => .{ .global = {} },
                    .module => .{ .module = {} },
                    .function => .{ .function = undefined },
                    .loop => .{ .loop = {} },
                },
                .offset = if (self.id == .loop) @truncate(u16, self.symbols.items().len) else 0,
                .parent = self,
                .allocator = self.allocator,
            };
            return new_scope;
        }

        /// Defines a new symbol and saves it in the symbol table
        /// Returns an error if Symbol already exists
        fn define(
            self: *Scope,
            name: []const u8,
            mutable: bool,
            node: Node,
            forward_declared: bool,
            is_pub: bool,
            index: ?u16,
        ) !?*Symbol {
            if (self.symbols.contains(name)) return null;

            const new_index = index orelse @intCast(u16, self.symbols.items().len);

            const symbol = try self.allocator.create(Symbol);
            symbol.* = .{
                .name = name,
                .mutable = mutable,
                .index = new_index + self.offset,
                .scope = self.id,
                .node = node,
                .forward_declared = forward_declared,
                .ident = undefined,
                .is_pub = is_pub,
            };

            try self.symbols.putNoClobber(self.allocator, name, symbol);
            return symbol;
        }

        /// Retrieves a `Symbol` from the Scopes symbol table, returns null if not found
        fn resolve(self: *const Scope, name: []const u8) ?*Symbol {
            return self.symbols.get(name);
        }

        /// Cleans up the memory of the `Scope`
        fn deinit(self: *Scope) void {
            for (self.symbols.items()) |entry| {
                self.allocator.destroy(entry.value);
            }
            self.symbols.deinit(self.allocator);
            self.allocator.destroy(self);
        }
    };

    /// Frees up any memory allocated by the compiler
    fn deinit(self: *Compiler) void {
        var it = self.modules.iterator();
        while (it.next()) |mod| {
            for (mod.value.symbols.items()) |entry| self.allocator.destroy(entry.value);
            mod.value.symbols.deinit(self.allocator);
            self.allocator.destroy(mod.value);
        }
        self.modules.deinit(self.allocator);
        self.exitScope();
        self.instructions.deinit(self.allocator);
        for (self.module_states.items) |state| {
            state.promote(self.allocator).deinit();
        }
        self.module_states.deinit(self.allocator);
        self.* = undefined;
    }

    /// Returns `Error.CompilerError` and appends an error message to the `errors` list.
    fn fail(self: *Compiler, comptime msg: []const u8, index: usize, args: anytype) Error {
        try self.errors.add(msg, index, .err, args);
        return Error.CompilerError;
    }

    /// Sets the current `Scope` to its parent's scope and cleans up the closing scope's memory
    fn exitScope(self: *Compiler) void {
        if (self.scope.id == .global) return; // can't escape the global scope
        if (self.scope.parent) |parent| {
            const old = self.scope;
            self.scope = parent;
            old.deinit();
        }
    }

    /// Creates a new Scope with the given Id, then sets the new scope as the current
    fn createScope(self: *Compiler, id: Scope.Id) !void {
        self.scope = try self.scope.fork(id);
    }

    /// Recursively looks for the scope with the given Tag
    fn findScope(self: *Compiler, scope: *const Scope, tag: Scope.Id) ?*const Scope {
        if (scope.id == tag) return scope;
        return if (scope.parent) |parent| self.findScope(parent, tag) else null;
    }

    /// Attempts to resolve a symbol from the symbol table
    /// If not found, will attempt to resolve it from a parent scope
    fn resolveSymbol(self: *Compiler, scope: *const Scope, name: []const u8) ?*Symbol {
        return scope.resolve(name) orelse if (scope.id != .global and scope.parent != null)
            self.resolveSymbol(scope.parent.?, name)
        else
            null;
    }

    /// Defines a new symbol in the current scope
    fn defineSymbol(
        self: *Compiler,
        name: []const u8,
        mutable: bool,
        node: Node,
        forward_declared: bool,
        is_pub: bool,
    ) !?*Symbol {
        const index: ?u16 = if (self.scope.id == .global or self.scope.id == .module) self.gc else null;
        if (try self.scope.define(name, mutable, node, forward_declared, is_pub, index)) |symbol| {
            if (index != null) self.gc += 1;
            return symbol;
        } else return null;
    }

    /// Returns a sifu `Type` based on the given node
    fn resolveType(self: *Compiler, node: Node) !Node {
        if (node.getType()) |t| return t;

        return switch (node) {
            .identifier => |id| {
                const symbol = self.resolveSymbol(self.scope, id.value) orelse
                    return self.fail("'{s}' is undefined", id.token.start, .{id.value});

                return self.resolveType(symbol.node);
            },
            .infix => |inf| return self.resolveType(inf.left),
            .declaration => |decl| {
                if (decl.type_def) |td| return td.getType().?;

                return self.resolveType(decl.value);
            },
            .index => |index| return self.resolveType(index.left),
            .call_expression => |cal| return self.resolveType(cal.function),
            .slice => |slice| return self.resolveType(slice.left),
            else => std.debug.panic("TODO, implement type resolving for type: {s}\n", .{node}),
        };
    }

    /// Resolves the inner type of a node. i.e. this will return `Type.integer` for a list []int
    fn resolveScalarType(self: *Compiler, node: Node) Error!Node {
        if (node.getInnerType()) |i| return i;
        return switch (node) {
            .identifier => |id| {
                return self.resolveSymbol(
                    self.scope,
                    id.value,
                ).node orelse
                    return self.fail("'{s}' is undefined", id.token.start, .{id.value});
            },
            .infix => |inf| return self.resolveScalarType(inf.left),
            .declaration => |decl| {
                if (decl.type_def) |td| return td.getInnerType().?;

                return self.resolveScalarType(decl.value);
            },
            .index => |index| {
                const temp_type = try self.resolveScalarType(index.left);
                if (temp_type == .module) {
                    const function_name = index.index.string_lit.value;
                    const symbol = self.resolveSymbol(self.scope, index.left.identifier.value) orelse
                        return self.fail(
                        "'{s}' is undefined",
                        index.left.tokenPos(),
                        .{index.left.identifier.value},
                    );

                    const mod: *Module = self.modules.get(symbol.node.declaration.value.import.value.string_lit.value) orelse
                        return Node.function; // Module imported by interpreter, therefore just return it as a function

                    const function_symbol: *Symbol = mod.symbols.get(function_name) orelse
                        return self.fail("Module does not contain function '{s}'", index.index.tokenPos(), .{function_name});

                    return self.resolveScalarType(function_symbol.node);
                }

                return self.resolveScalarType(index.left);
            },
            .call_expression => |cal| return self.resolveScalarType(cal.function),
            .slice => |slice| return self.resolveScalarType(slice.left),
            else => std.debug.panic("TODO, implement scalar type resolving for type: {s}\n", .{node.getType()}),
        };
    }

    /// Retrieves all symbols for Nodes of type declaration
    fn forwardDeclareNodes(self: *Compiler, nodes: []const Node) !void {
        for (nodes) |node| {
            if (node != .declaration) continue;
            const decl = node.declaration;

            if (decl.value == .import) {
                try self.forwardDeclareImport(decl.value.import);
                continue;
            } else if (!canBeForwardDeclared(decl.value)) continue;

            const symbol = (try self.defineSymbol(
                decl.name.identifier.value,
                decl.mutable,
                node,
                true,
                decl.is_pub,
            )) orelse return self.fail(
                "'{s}' has already been declared",
                node.tokenPos(),
                .{decl.name.identifier.value},
            );

            symbol.ident = try self.ir.emitIdent(
                try self.resolveType(node),
                node.tokenPos(),
                symbol.name,
                .global,
                symbol.index,
            );
        }
        for (self.scope.symbols.items()) |entry| {
            const symbol: *Symbol = entry.value;

            const value = try self.resolveInst(symbol.node.declaration.value);
            const decl = try self.ir.emitDecl(
                symbol.node.tokenPos(),
                symbol.name,
                symbol.index,
                .global,
                symbol.is_pub,
                symbol.mutable,
                value,
            );

            try self.instructions.append(self.allocator, decl);
        }
    }

    /// Forward declares all functions from a module, so we can do type checking for imported
    /// functions.
    fn forwardDeclareImport(self: *Compiler, node: *const Node.Import) !void {
        const file_name = node.value.string_lit.value;
        if (self.modules.contains(file_name)) return;
        if (!std.mem.endsWith(u8, file_name, ".sifu")) return;

        const file = std.fs.cwd().openFile(file_name, .{}) catch
            return self.fail("Cannot open file with path '{s}'", node.value.tokenPos(), .{file_name});
        defer file.close();

        const size = file.getEndPos() catch return self.fail("Unable to find file size", node.value.tokenPos(), .{});
        const source = file.reader().readAllAlloc(self.allocator, size) catch return self.fail(
            "Failed to read content of file with path '{s}'",
            node.value.tokenPos(),
            .{file_name},
        );
        defer self.allocator.free(source);

        const tree = try parser.parse(self.allocator, source, self.errors);
        errdefer tree.deinit();

        const module = try self.allocator.create(Module);
        errdefer self.allocator.destroy(module);

        module.* = .{ .symbols = SymbolTable{}, .compiled = false };
        errdefer module.symbols.deinit(self.allocator);

        for (tree.nodes) |n| {
            if (n != .declaration or n.declaration.value != .func_lit) continue;
            if (!n.declaration.is_pub) continue; // only public declarations

            const decl = n.declaration;
            const name = decl.name.identifier.value;

            if (module.symbols.contains(name))
                return self.fail("Identifier '{s}' already exists", n.declaration.name.tokenPos(), .{name});

            const symbol = try self.allocator.create(Symbol);
            symbol.* = .{
                .name = name,
                .mutable = decl.mutable,
                .scope = .global,
                .node = n,
                .forward_declared = true,
                .index = self.gc,
                .ident = undefined,
                .is_pub = decl.is_pub,
            };

            try module.symbols.putNoClobber(self.allocator, name, symbol);

            self.gc += 1;
        }

        try self.modules.putNoClobber(self.allocator, file_name, module);
        try self.module_states.append(self.allocator, tree.arena);
    }
};
